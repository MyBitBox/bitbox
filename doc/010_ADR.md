# ADR (Architecture Decision Record)

## 1. 개요

본 문서는 프로젝트의 주요 아키텍처 결정을 기록하기 위한 ADR(Architecture Decision Record)입니다. 지금까지 논의된 내용을 바탕으로 작성되었으며, 향후 개발 과정에서 추가적인 결정 사항이 발생하면 업데이트될 예정입니다.

## 2. ADR 목록

| ADR ID | 제목                                                     | 상태    |
| ------ | -------------------------------------------------------- | ----- |
| ADR-001 | 백엔드 프레임워크 선택: FastAPI                             | 확정  |
| ADR-002 | 프론트엔드 기술 스택 선택: 바닐라 JavaScript                    | 확정  |
| ADR-003 | 데이터베이스 선택: SQLAlchemy (ORM) + SQLite3            | 확정  |
| ADR-004 | API 설계 스타일: RESTful API                              | 확정  |
| ADR-005 | 인증 방식 선택: JWT (JSON Web Token)                       | 확정  |
| ADR-006 | AI 모델 선택 및 연동 방식: OpenAI API (GPT-3.5/4)          | 확정  |
| ADR-007 | 코드 버전 관리 전략: Git Flow                            | 확정  |
| ADR-008 | 배포 전략: Docker를 이용한 컨테이너 배포                      | 확정  |
| ADR-009 | 퀴즈 유형: 객관식                                          | 확정   |
| ADR-010 | Frontend/Backend 모노레포 구조 채택                          | 확정 |
| ADR-011 | Backend 폴더 구조 모듈화                                      | 확정 |

## 3. ADR 상세 내용

### 3.1. ADR-001: 백엔드 프레임워크 선택: FastAPI

*   **상태:** 확정
*   **결정:** 백엔드 프레임워크로 FastAPI를 사용한다.
*   **배경:**
    *   FastAPI는 현대적인 파이썬 웹 프레임워크로, 높은 성능과 쉬운 사용성을 제공한다.
    *   자동 API 문서 생성 기능(Swagger/ReDoc)은 개발 및 유지보수를 용이하게 한다.
    *   Pydantic을 이용한 데이터 유효성 검사 및 타입 힌팅 기능은 안정적인 API 개발을 지원한다.
    *   비동기 프로그래밍 지원은 I/O 바운드 작업에 효율적이다.
*   **대안:** Flask, Django REST Framework 등
*   **결정 이유:**
    *   FastAPI는 성능, 사용성, 개발 편의성 측면에서 다른 대안보다 우수하다.
    *   본 프로젝트의 요구사항에 적합하며, 향후 확장 가능성도 높다.
*   **결과:** FastAPI를 사용하여 백엔드 개발을 진행한다.

### 3.2. ADR-002: 프론트엔드 기술 스택 선택: 바닐라 JavaScript

*   **상태:** 확정
*   **결정:** 프론트엔드는 바닐라 JavaScript, HTML, CSS를 사용하여 개발한다.
*   **배경:**
    *   MVP 버전에서는 복잡한 프레임워크 없이 핵심 기능 구현에 집중한다.
    *   바닐라 JavaScript는 가볍고 학습 곡선이 낮아 빠른 개발이 가능하다.
    *   복잡한 UI나 컴포넌트 관리 필요성이 적다.
*   **대안:** React, Vue, Angular 등
*   **결정 이유:**
    *   MVP 단계에서는 프레임워크의 오버헤드 없이 빠른 개발이 목표이다.
    *   바닐라 JavaScript는 프레임워크 학습에 필요한 시간을 절약할 수 있다.
    *   추후 필요에 따라 프레임워크 도입을 고려할 수 있다.
*   **결과:** 바닐라 JavaScript, HTML, CSS를 사용하여 프론트엔드 개발을 진행한다.

### 3.3. ADR-003: 데이터베이스 선택: SQLAlchemy (ORM) + SQLite3

*   **상태:** 확정
*   **결정:** 데이터베이스는 SQLAlchemy ORM을 사용하여 SQLite3를 사용한다.
*   **배경:**
    *   SQLAlchemy는 강력한 ORM으로, 다양한 데이터베이스를 지원하며 코드의 유지보수성을 높인다.
    *   SQLite3는 간단하고 파일 기반의 데이터베이스로 MVP 개발 단계에 적합하다.
    *   SQLAlchemy는 데이터베이스 마이그레이션 기능도 지원한다.
*   **대안:** PostgreSQL, MySQL, MongoDB 등
*   **결정 이유:**
    *   SQLite3는 MVP 개발에 필요한 기능을 제공하며 설정이 간편하다.
    *   SQLAlchemy는 ORM을 통해 데이터베이스 접근을 추상화하고, 생산성을 높인다.
    *    빠른 개발과 테스트에 적합하다.
*   **결과:** SQLAlchemy ORM을 사용하여 SQLite3를 사용한다.

### 3.4. ADR-004: API 설계 스타일: RESTful API

*   **상태:** 확정
*   **결정:** API는 RESTful 스타일로 설계한다.
*   **배경:**
    *   RESTful API는 표준화된 디자인으로, 쉽게 이해하고 사용할 수 있다.
    *   HTTP 메소드(GET, POST, PUT, DELETE)를 활용하여 리소스를 관리한다.
    *   JSON 형식으로 데이터를 주고받는다.
*   **대안:** GraphQL 등
*   **결정 이유:**
    *   RESTful API는 널리 사용되는 디자인 패턴으로, 많은 개발자들이 익숙하다.
    *   본 프로젝트의 요구사항에 적합하며, 복잡하지 않은 API를 설계하는 데 효율적이다.
*   **결과:** RESTful API 스타일로 API를 설계한다.

### 3.5. ADR-005: 인증 방식 선택: JWT (JSON Web Token)

*   **상태:** 확정
*   **결정:** 사용자 인증 방식은 JWT를 사용한다.
*   **배경:**
    *   JWT는 토큰 기반 인증 방식으로, 서버에 사용자 정보를 저장하지 않고 클라이언트에서 토큰을 관리한다.
    *   JWT는 보안성이 높고, 확장성이 뛰어나다.
    *   FastAPI에서 JWT 인증을 쉽게 구현할 수 있다.
*   **대안:** 세션 기반 인증 등
*   **결정 이유:**
    *   JWT는 stateless 인증 방식으로, 서버의 확장성을 높이고, 클라이언트와 서버 간의 연동을 단순화한다.
    *   JWT는 보안성이 높고, 여러 도메인에서 사용 가능하다.
*   **결과:** JWT를 사용하여 사용자 인증을 구현한다.

### 3.6. ADR-006: AI 모델 선택 및 연동 방식: OpenAI API (GPT-3.5/4)

*   **상태:** 확정
*   **결정:** AI 모델은 OpenAI API (GPT-3.5/4)를 사용하고, API를 통해 연동한다.
*   **배경:**
    *   OpenAI API는 강력한 자연어 처리 모델을 제공하며, 사용자 답변에 대한 상세 피드백을 제공하는 데 적합하다.
    *   API 연동을 통해 모델을 직접 학습하거나 배포할 필요가 없다.
    *   GPT-3.5/4 모델은 비교적 빠른 응답 속도와 높은 품질의 피드백을 제공한다.
*   **대안:** Hugging Face, 자체 학습 모델 등
*   **결정 이유:**
    *   OpenAI API는 개발 시간을 단축하고, 모델 성능을 빠르게 확보할 수 있다.
    *   API 연동은 서비스의 안정성을 높이고, 복잡한 모델 관리를 피할 수 있다.
*   **결과:** OpenAI API를 사용하여 AI 피드백 기능을 구현한다.

### 3.7. ADR-007: 코드 버전 관리 전략: Git Flow

*   **상태:** 확정
*   **결정:** 코드 버전 관리는 Git Flow 전략을 사용한다.
*   **배경:**
    *   Git Flow는 효율적인 브랜치 관리 전략을 제공한다.
    *   `main`, `develop`, `feature`, `release`, `hotfix` 브랜치를 사용하여 코드 변경 사항을 관리한다.
    *   개발자와 함께 협업할 때 코드 충돌을 줄이고 안정적인 배포를 가능하게 한다.
*   **대안:** GitHub Flow 등
*   **결정 이유:**
    *   Git Flow는 체계적인 개발 프로세스를 제공하며, 안정적인 버전 관리와 배포를 가능하게 한다.
    *   본 프로젝트의 규모와 개발팀 규모에 적합한 전략이다.
*   **결과:** Git Flow 전략으로 코드를 버전 관리한다.

### 3.8. ADR-008: 배포 전략: Docker를 이용한 컨테이너 배포

*   **상태:** 확정
*   **결정:** Docker를 사용하여 컨테이너 배포를 진행한다.
*   **배경:**
    *   Docker는 애플리케이션을 컨테이너로 패키징하여 배포 환경에 상관없이 일관된 실행 환경을 제공한다.
    *   컨테이너 배포는 배포 과정을 단순화하고, 배포 환경의 일관성을 유지한다.
    *   Docker Compose를 사용하여 여러 컨테이너를 쉽게 관리할 수 있다.
*   **대안:** VM 배포, 서버 직접 배포 등
*   **결정 이유:**
    *   Docker 컨테이너 배포는 개발 환경과 동일한 환경에서 서비스를 실행할 수 있도록 한다.
    *   배포 과정에서 생길 수 있는 문제점을 줄이고, 빠르게 배포할 수 있다.
*   **결과:** Docker 컨테이너를 이용하여 서비스를 배포한다.

### 3.9. ADR-009: 퀴즈 유형: 객관식

*   **상태:** 확정
*  **결정:** MVP 버전에서는 객관식 퀴즈만 제공한다.
*   **배경:**
    *   MVP 버전에서는 개발 복잡도를 낮추고 핵심 기능에 집중하기 위해 객관식 퀴즈를 선택한다.
    *   객관식 퀴즈는 개발과 구현이 비교적 단순하며, 사용자 인터페이스도 간단하게 구현할 수 있다.
*   **대안:** 주관식 퀴즈, 코딩 퀴즈 등 다양한 퀴즈 유형
*   **결정 이유:**
    *   빠른 MVP 출시를 위해 객관식으로 우선 구현하고, 추후 다양한 퀴즈 유형을 추가할 수 있다.
*   **결과:** MVP 버전에서는 객관식 퀴즈만 제공한다.

### 3.10. ADR-010: Frontend/Backend 모노레포 구조 채택

*   **상태:** 확정
*   **컨텍스트:**
    *   프로젝트 초기에 frontend와 backend를 별도의 저장소로 관리할지, 하나의 저장소로 관리할지 결정이 필요했습니다.
    *   프로젝트의 규모와 팀 구성, 개발 프로세스를 고려하여 결정해야 했습니다.
*   **결정:** Frontend와 Backend를 하나의 Git 저장소에서 관리하는 모노레포 구조를 채택했습니다.
*   **결정 이유:**
    *   1. **간단한 프로젝트 관리**
        *   작은 규모의 프로젝트에서는 단일 저장소가 관리하기 더 용이합니다.
        *   버전 관리와 배포가 더 단순해집니다.
    *   2. **빠른 개발 속도**
        *   Frontend와 Backend 간의 코드 공유가 쉽습니다.
        *   API 인터페이스 변경 시 즉시 양쪽을 동시에 수정할 수 있습니다.
    *   3. **일관된 개발 환경**
        *   프로젝트 설정과 개발 환경을 통일할 수 있습니다.
        *   공통된 lint 규칙과 포맷팅을 적용할 수 있습니다.
*   **결과:**
    *   Frontend 코드는 `/frontend` 디렉토리에 위치
    *   Backend 코드는 `/backend` 디렉토리에 위치
    *   공통 문서는 `/doc` 디렉토리에 위치

### 3.11. ADR-011: Backend 폴더 구조 모듈화

*   **상태:** 확정
*   **컨텍스트:**
    *   Backend 코드베이스가 커짐에 따라 체계적인 구조화가 필요했습니다.
    *   코드의 재사용성과 유지보수성을 높이기 위한 구조가 필요했습니다.
*   **결정:** Backend 코드를 다음과 같은 모듈로 분리하여 구조화했습니다:
    *   `models/`: 데이터베이스 모델 정의
    *   `schemas/`: Pydantic 스키마 정의
    *   `api/`: API 엔드포인트 및 라우터
    *   `core/`: 핵심 설정 및 유틸리티
*   **결정 이유:**
    *   1. **관심사의 분리**
        *   각 모듈은 명확한 책임과 역할을 가집니다.
        *   코드의 응집도를 높이고 결합도를 낮춥니다.
    *   2. **코드 재사용성**
        *   공통 기능을 core 모듈로 분리하여 재사용성을 높입니다.
        *   모델과 스키마를 분리하여 데이터 검증과 변환을 명확히 합니다.
    *   3. **유지보수성**
        *   모듈화된 구조로 코드 변경의 영향 범위를 최소화합니다.
        *   새로운 기능 추가 시 적절한 모듈에 쉽게 통합할 수 있습니다.
*   **결과:**
```
backend/
├── app/
│   ├── models/        # SQLAlchemy 모델
│   ├── schemas/       # Pydantic 스키마
│   ├── api/          # API 엔드포인트
│   └── core/         # 설정 및 유틸리티
└── tests/            # 테스트 코드
```

이 구조는 FastAPI의 권장 사항과 일치하며, 프로젝트의 확장성을 고려한 설계입니다.

## 4. 결론

본 ADR은 프로젝트의 주요 아키텍처 결정 사항을 기록하고 있습니다. 이 문서는 지속적으로 업데이트되어야 하며, 새로운 결정 사항이 발생할 때마다 추가되어야 합니다. ADR 문서를 통해 프로젝트의 아키텍처에 대한 이해도를 높이고, 개발 과정에서 일관성을 유지할 수 있도록 합니다.